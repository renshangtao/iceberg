/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

package org.apache.iceberg.encryption;

import java.nio.ByteBuffer;
import java.security.SecureRandom;
import org.apache.iceberg.io.InputFile;
import org.apache.iceberg.io.OutputFile;
import org.apache.iceberg.relocated.com.google.common.base.Preconditions;

/**
 *
 * 与KMS结合使用的加密管理器可以加密{@link OutputFile}和解密*{@link InputFile}
 * 信封加密使用密钥包装策略，其中密钥加密密钥（KEK）用于包装或打开用于加密底层文件的数据加密密钥DEK
 *
 * Encryption manager which in conjunction with a KMS can encrypt {@link OutputFile} and decrypt
 * {@link InputFile}. Envelope encryption uses a key wrapping strategy, where a Key Encryption Key (KEK) is used to
 * wrap or unwrap a Data Encryption Key DEK which is used to encrypt the underlying files.
 *
 * 百度翻译太完美了
 * 当为输出文件生成新的DEK时，此类将首先尝试让KMS生成一个新密钥。如果KMS不支持密钥生成，
 * 则将通过从写入文件的JVM上的{@link SecureRandom}中提取字节来生成新密钥。
 * When generating new DEKs for OutputFiles, this class will first attempt to have the KMS generate a new key. If the
 * KMS does not support key generation a new key will be produced by pulling bytes from a {@link SecureRandom} on the
 * JVM writing the file.
 */
public class EnvelopeEncryptionManager implements EncryptionManager {
    private final EnvelopeConfiguration dataEncryptionConfig;
    private final boolean nativeFormatEncryption;
    private final KmsClient kmsClient;
    private final int dataKeyLength;
    private final boolean kmsGeneratedKeys;

    private transient volatile SecureRandom workerRNG = null;

    public static final String encryptionConfigMismatchMessagePrefix =
            "Cannot create encryption manager - detected mismatch between client encryption properties and table " +
                    "encryption properties. Mismatch can be caused by changing encryption properties after table creation " +
                    "(currently not supported), or by malicious tampering with table properties kept in metadata.json in " +
                    "storage. Mismatch details: ";
    /*无法创建加密管理器-检测到客户端加密属性和表加密属性之间不匹配。
      不匹配可能由创建表后更改加密属性（当前不支持）或恶意篡改metadata.json 文件中的元数据中的表属性引起。不匹配的详细信息
    */

    /**
     * @param nativeFormatEncryption true for native encryption inside file formats (Parquet or ORC), false for generic
     *                               encryption of file streams
     *                               true用于文件格式（Parquet或ORC）原生的加密，false用于文件流的通用加密
     * @param dataEncryptionConfig configuration for encryption of data files. Future versions will add configuration for
     *                             encryption of metadata files
     *                             未来版本将添加元数据文件加密的配置，--目前只有数据加密
     * @param kmsClient Client of KMS used to wrap/unwrap keys in envelope encryption
     * @param dataKeyLength If DEKs are not generated by KMS, they will be randomly generated by Iceberg using this length
     */
    public EnvelopeEncryptionManager(boolean nativeFormatEncryption,  EnvelopeConfiguration dataEncryptionConfig,
                                     KmsClient kmsClient, int dataKeyLength) {
        if (!nativeFormatEncryption) {
            /* 目前仅支持由底层文件格式提供的加密 */
            throw new UnsupportedOperationException("EnvelopeEncryptionManager currently only supports encryption " +
                    "provided by the underlying file format.");
        }
        this.nativeFormatEncryption = nativeFormatEncryption;
        Preconditions.checkNotNull(dataEncryptionConfig,
                "Cannot create EnvelopeEncryptionManager because data encryption config is not passed");
        this.dataEncryptionConfig = dataEncryptionConfig;
        Preconditions.checkNotNull(dataEncryptionConfig.kekId(),
                "Cannot create EnvelopeEncryptionManager because table key encryption key ID is not specified");
        Preconditions.checkNotNull(kmsClient,
                "Cannot create EnvelopeEncryptionManager because KmsClient is null");
        this.kmsClient = kmsClient;
        this.dataKeyLength = dataKeyLength;
        this.kmsGeneratedKeys = kmsClient.supportsKeyGeneration();
    }

    @Override
    public EncryptedOutputFile encrypt(OutputFile rawOutput) {
        EnvelopeMetadata metadata = generateEnvelopeMetadata(dataEncryptionConfig);

        if (nativeFormatEncryption) {
            NativeFileCryptoParameters nativeEncryptParams = NativeFileCryptoParameters.create(metadata.dek())
                    .encryptionAlgorithm(metadata.algorithm())
                    .build();

            if (!(rawOutput instanceof NativelyEncryptedFile)) {
                throw new RuntimeException("Can't natively encrypt " + rawOutput.location() + " because the class " +
                        rawOutput.getClass() + " doesn't implement NativelyEncryptedFile interface");
            }

            ((NativelyEncryptedFile) rawOutput).setNativeCryptoParameters(nativeEncryptParams);

            return new BaseEncryptedOutputFile(rawOutput, metadata);
        } else {
            throw new UnsupportedOperationException("EnvelopeEncryptionManager currently supports only file formats which " +
                    "have native encryption implementations");
        }
    }

    @Override
    public InputFile decrypt(EncryptedInputFile encrypted) {
        if (encrypted.keyMetadata().buffer() == null) { // unencrypted file
            return encrypted.encryptedInputFile();
        }
        EnvelopeMetadata metadata = EnvelopeMetadataParser.fromJson(encrypted.keyMetadata().buffer());
        ByteBuffer fileDek = kmsClient.unwrapKey(metadata.wrappedDek(), metadata.kekId());

        if (nativeFormatEncryption) {
            // Pushdown to data formats with native decryption support (such as Parquet)
            NativeFileCryptoParameters nativeDecryptParams = NativeFileCryptoParameters.create(fileDek).build();
            InputFile rawInput = encrypted.encryptedInputFile();

            if (!(rawInput instanceof NativelyEncryptedFile)) {
                throw new RuntimeException("Can't natively decrypt " + rawInput.location() + " because the class " +
                        rawInput.getClass() + " doesn't implement NativelyEncryptedFile interface");
            }

            ((NativelyEncryptedFile) rawInput).setNativeCryptoParameters(nativeDecryptParams);

            return rawInput;
        } else {
            throw new UnsupportedOperationException("EnvelopeEncryptionManager currently supports only file formats which " +
                    "have native encryption implementations");
        }
    }

    private EnvelopeMetadata generateEnvelopeMetadata(EnvelopeConfiguration config) {
        String tableKekID = config.kekId();
        byte[] fileDek;
        String wrappedFileDEK;

        /* kms是否支持生成加密密钥 true*/
        if (kmsGeneratedKeys) {
            KmsClient.KeyGenerationResult generatedDek = kmsClient.generateKey(tableKekID);
            fileDek = generatedDek.key().array();
            wrappedFileDEK = generatedDek.wrappedKey();
        } else {
            /* Java自己生成 */
            if (null == workerRNG) {
                workerRNG = new SecureRandom();
            }
            fileDek = new byte[dataKeyLength];
            workerRNG.nextBytes(fileDek);
            wrappedFileDEK = kmsClient.wrapKey(ByteBuffer.wrap(fileDek), tableKekID);
        }

        EnvelopeMetadata fileEnvelopeMetadata = new EnvelopeMetadata(tableKekID, wrappedFileDEK, config.algorithm());
        fileEnvelopeMetadata.setDek(ByteBuffer.wrap(fileDek));

        return fileEnvelopeMetadata;
    }
}